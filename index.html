<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Custom Grid Element</title>
        <style>
            body {
                display: flex;
                flex-wrap: wrap;
            }

            .fab-container {
                position: fixed;
                top: 20px;
                right: 20px;
                z-index: 1000;
            }

            .fab-button {
                width: 50px;
                height: 50px;
                background-color: #4CAF50;
                color: white;
                font-size: 30px;
                line-height: 50px;
                text-align: center;
                border-radius: 5px;
                cursor: pointer;
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            }

            .fab-dropdown {
                display: flex;
                flex-direction: column;
                align-items: flex-end;
                margin-top: 10px;
            }

            /* Hide via class */
            .hidden {
                display: none !important;
            }

            .dropdown-btn {
                background-color: #f1f1f1;
                border: none;
                padding: 10px 15px;
                margin: 5px 0;
                border-radius: 4px;
                cursor: pointer;
            }


            path-finding-simulator {
                display: flex;
                flex-direction: column;
                border: 2px solid rgb(145, 145, 145);
                background-color: #676090;
                width: fit-content;
                padding: 20px;
                border-radius: 8px;      
                resize: both;
            }

            .panel{
                background-color: #febcd5;
                height: 150px;
                min-width: 200px;
                margin-top: 1rem;
                border-radius: 10px;
                display: flex;
                flex-wrap: wrap;
            }

            .grid-map {
                background-color: rgb(182, 182, 182);
                display: grid;
                gap: 1px;
                /* Inspect why this is needed. its so hardcoded */
                padding-right: 3px;
                padding-bottom: 3px; 
            }

            .cell {
                width: 38px;
                height: 38px;
                background-color: #eee;
                border: 1px solid #ccc;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                user-select: none;
            }

            .wall {
                background-color: #736373;
            }

            .end {
                background-color: green;
                border-radius: 14px;
            }

            .start {
                background-color: rgb(212, 56, 18);
                border-radius: 14px;
            }

            .empty {
                
            }
            
            button {
                color: rgb(0, 0, 0);
                font-weight: 700;
                height: fit-content;
                min-width: fit-content;
                margin: 10px;
                border-radius: 10px;
                padding: 10px;
            }
            .highlight{
                background-color: yellow ;
            }
            .simulate-button {
                background-color: #2e67c3;
            }
            
            .queued {
                background-color: yellow !important;
            }
        </style>
    </head>
    <body>

        <div class="fab-container">
            <div class="fab-button" onclick="toggleDropdown()">+</div>
            <div class="fab-dropdown hidden" id="fabDropdown">
              <button class="dropdown-btn" onclick="newSim()">New BFS</button>
            </div>
        </div>
          
        <path-finding-simulator ></path-finding-simulator>

        <script>
            Array.prototype.get2DNeighbors = function(current_row, current_col) {
                const neighbors = [];

                // Check Up-Left (-1, -1)
                if (current_row - 1 >= 0 && current_col - 1 >= 0) {
                    neighbors.push(this[current_row - 1][current_col - 1]);
                }

                // Check Up (-1, 0)
                if (current_row - 1 >= 0) {
                    neighbors.push(this[current_row - 1][current_col]);
                }

                // Check Up-Right (-1, +1)
                if (current_row - 1 >= 0 && current_col + 1 < this[0].length) {
                    neighbors.push(this[current_row - 1][current_col + 1]);
                }

                // Check Right (0, +1)
                if (current_col + 1 < this[0].length) {
                    neighbors.push(this[current_row][current_col + 1]);
                }

                // Check Down-Right (+1, +1)
                if (current_row + 1 < this.length && current_col + 1 < this[0].length) {
                    neighbors.push(this[current_row + 1][current_col + 1]);
                }

                // Check Down (+1, 0)
                if (current_row + 1 < this.length) {
                    neighbors.push(this[current_row + 1][current_col]);
                }

                // Check Down-Left (+1, -1)
                if (current_row + 1 < this.length && current_col - 1 >= 0) {
                    neighbors.push(this[current_row + 1][current_col - 1]);
                }

                // Check Left (0, -1)
                if (current_col - 1 >= 0) {
                    neighbors.push(this[current_row][current_col - 1]);
                }

                return neighbors;
            };

            class Simulator extends HTMLElement {
                constructor(algo) {
                    super();
                    this.rows = parseInt(this.getAttribute('rows')) || 10;
                    this.cols = parseInt(this.getAttribute('cols')) || 10; 
                    this.arr = [];

                    this.algo = algo || 'bfs'
                    this.simulation_state = 'creative'
                    this.start_cell = null
                    this.end_cell = null 
                }

                static Queue = class {
                    constructor() {
                    this.items = {};
                    this.head = 0;
                    this.tail = 0;
                    }

                    push(element) {
                        element.style.backgroundColor = 'blue';
                        element.isVisited = true;
                        this.items[this.tail] = element;
                        this.tail++;
                    }

                    pop() {
                        if (this.isEmpty()) return null;

                        const value = this.items[this.head];
                        delete this.items[this.head];
                        this.head++;
                        value.style.backgroundColor = 'yellow';
                        return value;
                    }

                    isEmpty() {
                        return this.head === this.tail;
                    }
                };
                
                simulate(){
                    // this is still bfs
                    const queue = new Simulator.Queue(); // replace with more efficient someday
                    let current_cell = this.start_cell;
                    queue.push(current_cell)
                    const bfs = () => {
                        if(current_cell === this.end_cell){
                            console.log('congrats')
                            return
                        }
                        console.log('animating')
                
                        const neighbors = this.arr.get2DNeighbors(current_cell.row, current_cell.col);
                        for(let n of neighbors){
                            console.log(n.isVisited)
                            if (n.type != 'wall' && !n.isVisited){
                                queue.push(n)
                            }
                        }
                        if(queue.isEmpty()){
                            return
                        }
                        current_cell = queue.pop();
                        setTimeout(bfs,20);
                    }
                    bfs();
                }

                setSimulationState(state) {
                    const states = ['creative', 'select-start', 'select-end', 'simulating']
                    if (!states.includes(state)) return
                    this.simulation_state = state
                }

                connectedCallback() {
                    this.render();
                }

                render() {
                    const grid_container_div = document.createElement('div');
                    grid_container_div.classList.add('grid-map')
                    grid_container_div.style.gridTemplateColumns = `repeat(${this.cols}, 40px)`;
                    grid_container_div.style.gridTemplateRows = `repeat(${this.rows}, 40px)`;

                    const panel = document.createElement('div');
                    const select_end_button = document.createElement('button');
                    const select_start_button = document.createElement('button');
                    const simulate_button = document.createElement('button');
                    select_start_button.innerHTML = 'Select Start'
                    select_end_button.innerHTML = 'Select End'
                    simulate_button.innerHTML = 'Start Simulation'
                    select_start_button.classList.add('start')
                    select_end_button.classList.add('end')
                    simulate_button.classList.add('simulate-button')
                    
                    select_start_button.onclick = () => this.setSimulationState('select-start');
                    select_end_button.onclick = () => this.setSimulationState('select-end');
                    simulate_button.onclick = () => this.simulate();

                    panel.classList.add('panel');
                    panel.appendChild(select_start_button)
                    panel.appendChild(select_end_button)
                    panel.appendChild(simulate_button)

                    this.appendChild(grid_container_div)
                    this.appendChild(panel);

                    for (let r = 0; r < this.rows; r++) {
                        const col = []
                        for (let c = 0; c < this.cols; c++) {
                            const cell = document.createElement('div');
                            grid_container_div.appendChild(cell);
                            cell.classList.add('cell');
                            cell.type = 'empty'
                            cell.row = r;
                            cell.col = c;
                            cell.isVisited = false;
                            cell.setType= function (type = 'empty') {
                                const types = ['empty', 'start', 'end', 'wall']
                                types.forEach(t => this.classList.remove(t));
                                this.classList.add(type);
                                
                                this.type = type
                            }
                            
                            cell.addEventListener('click', () => {

                                if (this.simulation_state == 'select-start'){
                                    this.start_cell.setType()
                                    cell.setType('start')
                                    this.start_cell = cell

                                    this.setSimulationState('creative')
                                    return
                                }
                                if (this.simulation_state == 'select-end'){
                                    this.end_cell.setType()     
                                    cell.setType('end')
                                    this.end_cell = cell

                                    this.setSimulationState('creative')
                                    return
                                }

                                if(cell.type == 'start' || cell.type == 'end'){
                                    return
                                }
                                cell.type == 'empty' ? cell.setType('wall') : cell.setType('empty')
                            });
                            
                            col.push(cell)
                        }
                        this.arr.push(col)
                    }

                    
                    const start_cell = this.arr[0][0]
                    const end_cell = this.arr[this.rows-1][this.cols-1]
                    start_cell.setType('start')
                    end_cell.setType('end')
                    this.start_cell = start_cell
                    this.end_cell = end_cell
                }
            }
            customElements.define('path-finding-simulator', Simulator);

            function newSim() {
                console.log('newsim')
                const sim = document.createElement('path-finding-simulator')
                document.body.appendChild(sim);
            }
            function toggleDropdown() {
                const dropdown = document.getElementById('fabDropdown');
                dropdown.classList.toggle('hidden');
            }


        </script>

    </body>
</html>
